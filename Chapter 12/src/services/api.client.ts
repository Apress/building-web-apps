/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.1.0.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get all categories.
     * @return Returns categories.
     */
    getAllCategories(): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCategories(_response);
        });
    }

    protected processGetAllCategories(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(<any>null);
    }

    /**
     * Gets a single category.
     * @param id Primary Key of the category to retrieve
     * @return Returns single Category.
     */
    getCategory(id: number): Promise<Category> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Category.fromJS(resultData200) : new Category();
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }

    /**
     * Gets all product for a single category.
     * @param categoryId Primary Key of the category to retrieve
     * @return Returns all products for a single category.
     */
    getCategoryProducts(categoryId: number): Promise<Product[]> {
        let url_ = this.baseUrl + "/api/Category/{categoryId}/products";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategoryProducts(_response);
        });
    }

    protected processGetCategoryProducts(response: Response): Promise<Product[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product[]>(<any>null);
    }

    /**
     * Get all customers.
     * @return Returns customers.
     */
    getAllCustomers(): Promise<Customer[]> {
        let url_ = this.baseUrl + "/api/Customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCustomers(_response);
        });
    }

    protected processGetAllCustomers(response: Response): Promise<Customer[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Customer.fromJS(item));
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer[]>(<any>null);
    }

    /**
     * Gets a single customer.
     * @param id Primary Key of the customer to retrieve
     * @return Returns single customer.
     */
    getCustomer(id: number): Promise<Customer> {
        let url_ = this.baseUrl + "/api/Customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCustomer(_response);
        });
    }

    protected processGetCustomer(response: Response): Promise<Customer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Customer.fromJS(resultData200) : new Customer();
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Customer>(<any>null);
    }

    /**
     * Get order with Details for one customer
     * @param orderId Primary Key for the Order Table
     * @return Returns order with order details.
     */
    getOrderDetails(orderId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/OrderDetails/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrderDetails(_response);
        });
    }

    protected processGetOrderDetails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Order History for a customer (top line only)
     * @return Returns order history for a customer.
     */
    getOrderHistory(customerId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Orders/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrderHistory(_response);
        });
    }

    protected processGetOrderHistory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets a single product with category name.
     * @param id Primary Key of the product to retrieve
     * @return Returns single Product.
     */
    getProduct(id: number): Promise<Product> {
        let url_ = this.baseUrl + "/api/Product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProduct(_response);
        });
    }

    protected processGetProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * Get all featured Products with Category Name.
     * @return Returns featured Products.
     */
    getFeaturedProducts(): Promise<Product[]> {
        let url_ = this.baseUrl + "/api/Product/featured";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFeaturedProducts(_response);
        });
    }

    protected processGetFeaturedProducts(response: Response): Promise<Product[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product[]>(<any>null);
    }

    /**
     * Gets a single category.
     * @param searchString String to search the product name and product description description.
     * @return Returns matching products.
     */
    searchProducts(searchString: string): Promise<Product[]> {
        let url_ = this.baseUrl + "/api/Search/{searchString}";
        if (searchString === undefined || searchString === null)
            throw new Error("The parameter 'searchString' must be defined.");
        url_ = url_.replace("{searchString}", encodeURIComponent("" + searchString)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchProducts(_response);
        });
    }

    protected processSearchProducts(response: Response): Promise<Product[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Product.fromJS(item));
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product[]>(<any>null);
    }

    /**
     * Get Shopping Cart Records for a customer.
     * @param customerId Primary Key of the Customer
     * @return Returns all Shopping Cart Records for the customer
     */
    getShoppingCart(customerId: number): Promise<CartWithCustomerInfo> {
        let url_ = this.baseUrl + "/api/ShoppingCart/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShoppingCart(_response);
        });
    }

    protected processGetShoppingCart(response: Response): Promise<CartWithCustomerInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CartWithCustomerInfo.fromJS(resultData200) : new CartWithCustomerInfo();
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CartWithCustomerInfo>(<any>null);
    }

    /**
     * @param customer (optional) 
     * @return Success
     */
    purchase(customerId: number, customer?: Customer | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ShoppingCart/{customerId}/buy";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchase(_response);
        });
    }

    protected processPurchase(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get Shopping Cart Record for cart record id.
     * @return Returns single Shopping Cart Record
     */
    getShoppingCartRecord(recordId: number): Promise<CartRecordWithProductInfo> {
        let url_ = this.baseUrl + "/api/ShoppingCartRecord/{recordId}";
        if (recordId === undefined || recordId === null)
            throw new Error("The parameter 'recordId' must be defined.");
        url_ = url_.replace("{recordId}", encodeURIComponent("" + recordId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShoppingCartRecord(_response);
        });
    }

    protected processGetShoppingCartRecord(response: Response): Promise<CartRecordWithProductInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CartRecordWithProductInfo.fromJS(resultData200) : new CartRecordWithProductInfo();
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CartRecordWithProductInfo>(<any>null);
    }

    /**
     * Updates a Shopping Cart Record
     * @param recordId Primary key of the cart record
     * @param item (optional) Shopping Cart Record
                      {
                         "CustomerId": 1,
                         "Quantity": 2,
                         "ProductId": 34,
                      }
     * @return Returned new created item
     */
    updateCartRecord(recordId: number, item?: ShoppingCartRecord | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ShoppingCartRecord/{recordId}";
        if (recordId === undefined || recordId === null)
            throw new Error("The parameter 'recordId' must be defined.");
        url_ = url_.replace("{recordId}", encodeURIComponent("" + recordId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCartRecord(_response);
        });
    }

    protected processUpdateCartRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deletes a Shopping Cart Record
     * @param recordId Primary key of the cart record
     * @param item (optional) Shopping Cart Record
                      {
                         "CustomerId": 1,
                         "Quantity": 2,
                         "ProductId": 34,
                         "TimeStamp": "AAAAAAAAs+M="
                      }
     * @return Returned new created item
     */
    deleteCartRecord(recordId: number, item?: ShoppingCartRecord | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ShoppingCartRecord/{recordId}";
        if (recordId === undefined || recordId === null)
            throw new Error("The parameter 'recordId' must be defined.");
        url_ = url_.replace("{recordId}", encodeURIComponent("" + recordId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCartRecord(_response);
        });
    }

    protected processDeleteCartRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Creates a new Shopping Cart Record
     * @param customerId Primary key of the Customer
     * @param record (optional) Shopping Cart Record
                      {
                         "CustomerId": 1,
                         "Quantity": 2,
                         "ProductId": 34,
                      }
     * @return Returned new created item
     */
    addCartRecord(customerId: number, record?: ShoppingCartRecord | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ShoppingCartRecord/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(record);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCartRecord(_response);
        });
    }

    protected processAddCartRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    post(value?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Values";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    get1(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/test1";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet1(_response);
        });
    }

    protected processGet1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    get2(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Values/test2";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    get3(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/test3";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet3(_response);
        });
    }

    protected processGet3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    put(id: number, value?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class Category implements ICategory {
    categoryName?: string | null;
    products?: Product[] | null;
    id?: number | null;
    timeStamp?: string | null;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryName = data["CategoryName"] !== undefined ? data["CategoryName"] : <any>null;
            if (data["Products"] && data["Products"].constructor === Array) {
                this.products = [] as any;
                for (let item of data["Products"])
                    this.products!.push(Product.fromJS(item));
            }
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CategoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        if (this.products && this.products.constructor === Array) {
            data["Products"] = [];
            for (let item of this.products)
                data["Products"].push(item.toJSON());
        }
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface ICategory {
    categoryName?: string | null;
    products?: Product[] | null;
    id?: number | null;
    timeStamp?: string | null;
}

export class Product implements IProduct {
    details?: ProductDetails | null;
    isFeatured?: boolean | null;
    unitCost?: number | null;
    currentPrice?: number | null;
    unitsInStock?: number | null;
    categoryId!: number;
    shoppingCartRecords?: ShoppingCartRecord[] | null;
    orderDetails?: OrderDetail[] | null;
    categoryName?: string | null;
    id?: number | null;
    timeStamp?: string | null;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.details = data["Details"] ? ProductDetails.fromJS(data["Details"]) : <any>null;
            this.isFeatured = data["IsFeatured"] !== undefined ? data["IsFeatured"] : <any>null;
            this.unitCost = data["UnitCost"] !== undefined ? data["UnitCost"] : <any>null;
            this.currentPrice = data["CurrentPrice"] !== undefined ? data["CurrentPrice"] : <any>null;
            this.unitsInStock = data["UnitsInStock"] !== undefined ? data["UnitsInStock"] : <any>null;
            this.categoryId = data["CategoryId"] !== undefined ? data["CategoryId"] : <any>null;
            if (data["ShoppingCartRecords"] && data["ShoppingCartRecords"].constructor === Array) {
                this.shoppingCartRecords = [] as any;
                for (let item of data["ShoppingCartRecords"])
                    this.shoppingCartRecords!.push(ShoppingCartRecord.fromJS(item));
            }
            if (data["OrderDetails"] && data["OrderDetails"].constructor === Array) {
                this.orderDetails = [] as any;
                for (let item of data["OrderDetails"])
                    this.orderDetails!.push(OrderDetail.fromJS(item));
            }
            this.categoryName = data["CategoryName"] !== undefined ? data["CategoryName"] : <any>null;
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Details"] = this.details ? this.details.toJSON() : <any>null;
        data["IsFeatured"] = this.isFeatured !== undefined ? this.isFeatured : <any>null;
        data["UnitCost"] = this.unitCost !== undefined ? this.unitCost : <any>null;
        data["CurrentPrice"] = this.currentPrice !== undefined ? this.currentPrice : <any>null;
        data["UnitsInStock"] = this.unitsInStock !== undefined ? this.unitsInStock : <any>null;
        data["CategoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        if (this.shoppingCartRecords && this.shoppingCartRecords.constructor === Array) {
            data["ShoppingCartRecords"] = [];
            for (let item of this.shoppingCartRecords)
                data["ShoppingCartRecords"].push(item.toJSON());
        }
        if (this.orderDetails && this.orderDetails.constructor === Array) {
            data["OrderDetails"] = [];
            for (let item of this.orderDetails)
                data["OrderDetails"].push(item.toJSON());
        }
        data["CategoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface IProduct {
    details?: ProductDetails | null;
    isFeatured?: boolean | null;
    unitCost?: number | null;
    currentPrice?: number | null;
    unitsInStock?: number | null;
    categoryId: number;
    shoppingCartRecords?: ShoppingCartRecord[] | null;
    orderDetails?: OrderDetail[] | null;
    categoryName?: string | null;
    id?: number | null;
    timeStamp?: string | null;
}

export class ProductDetails implements IProductDetails {
    description?: string | null;
    modelNumber?: string | null;
    modelName?: string | null;
    productImage?: string | null;
    productImageLarge?: string | null;
    productImageThumb?: string | null;

    constructor(data?: IProductDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["Description"] !== undefined ? data["Description"] : <any>null;
            this.modelNumber = data["ModelNumber"] !== undefined ? data["ModelNumber"] : <any>null;
            this.modelName = data["ModelName"] !== undefined ? data["ModelName"] : <any>null;
            this.productImage = data["ProductImage"] !== undefined ? data["ProductImage"] : <any>null;
            this.productImageLarge = data["ProductImageLarge"] !== undefined ? data["ProductImageLarge"] : <any>null;
            this.productImageThumb = data["ProductImageThumb"] !== undefined ? data["ProductImageThumb"] : <any>null;
        }
    }

    static fromJS(data: any): ProductDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Description"] = this.description !== undefined ? this.description : <any>null;
        data["ModelNumber"] = this.modelNumber !== undefined ? this.modelNumber : <any>null;
        data["ModelName"] = this.modelName !== undefined ? this.modelName : <any>null;
        data["ProductImage"] = this.productImage !== undefined ? this.productImage : <any>null;
        data["ProductImageLarge"] = this.productImageLarge !== undefined ? this.productImageLarge : <any>null;
        data["ProductImageThumb"] = this.productImageThumb !== undefined ? this.productImageThumb : <any>null;
        return data; 
    }
}

export interface IProductDetails {
    description?: string | null;
    modelNumber?: string | null;
    modelName?: string | null;
    productImage?: string | null;
    productImageLarge?: string | null;
    productImageThumb?: string | null;
}

export class ShoppingCartRecord implements IShoppingCartRecord {
    dateCreated?: Date | null;
    customerId!: number;
    quantity!: number;
    lineItemTotal?: number | null;
    productId!: number;
    id?: number | null;
    timeStamp?: string | null;

    constructor(data?: IShoppingCartRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateCreated = data["DateCreated"] ? new Date(data["DateCreated"].toString()) : <any>null;
            this.customerId = data["CustomerId"] !== undefined ? data["CustomerId"] : <any>null;
            this.quantity = data["Quantity"] !== undefined ? data["Quantity"] : <any>null;
            this.lineItemTotal = data["LineItemTotal"] !== undefined ? data["LineItemTotal"] : <any>null;
            this.productId = data["ProductId"] !== undefined ? data["ProductId"] : <any>null;
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): ShoppingCartRecord {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DateCreated"] = this.dateCreated ? formatDate(this.dateCreated) : <any>null;
        data["CustomerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["Quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["LineItemTotal"] = this.lineItemTotal !== undefined ? this.lineItemTotal : <any>null;
        data["ProductId"] = this.productId !== undefined ? this.productId : <any>null;
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface IShoppingCartRecord {
    dateCreated?: Date | null;
    customerId: number;
    quantity: number;
    lineItemTotal?: number | null;
    productId: number;
    id?: number | null;
    timeStamp?: string | null;
}

export class OrderDetail implements IOrderDetail {
    orderNavigation?: Order | null;
    productNavigation?: Product | null;
    orderId!: number;
    productId!: number;
    quantity!: number;
    unitCost!: number;
    lineItemTotal?: number | null;
    id?: number | null;
    timeStamp?: string | null;

    constructor(data?: IOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderNavigation = data["OrderNavigation"] ? Order.fromJS(data["OrderNavigation"]) : <any>null;
            this.productNavigation = data["ProductNavigation"] ? Product.fromJS(data["ProductNavigation"]) : <any>null;
            this.orderId = data["OrderId"] !== undefined ? data["OrderId"] : <any>null;
            this.productId = data["ProductId"] !== undefined ? data["ProductId"] : <any>null;
            this.quantity = data["Quantity"] !== undefined ? data["Quantity"] : <any>null;
            this.unitCost = data["UnitCost"] !== undefined ? data["UnitCost"] : <any>null;
            this.lineItemTotal = data["LineItemTotal"] !== undefined ? data["LineItemTotal"] : <any>null;
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): OrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderNavigation"] = this.orderNavigation ? this.orderNavigation.toJSON() : <any>null;
        data["ProductNavigation"] = this.productNavigation ? this.productNavigation.toJSON() : <any>null;
        data["OrderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["ProductId"] = this.productId !== undefined ? this.productId : <any>null;
        data["Quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["UnitCost"] = this.unitCost !== undefined ? this.unitCost : <any>null;
        data["LineItemTotal"] = this.lineItemTotal !== undefined ? this.lineItemTotal : <any>null;
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface IOrderDetail {
    orderNavigation?: Order | null;
    productNavigation?: Product | null;
    orderId: number;
    productId: number;
    quantity: number;
    unitCost: number;
    lineItemTotal?: number | null;
    id?: number | null;
    timeStamp?: string | null;
}

export class Order implements IOrder {
    customerNavigation?: Customer | null;
    orderDetails?: OrderDetail[] | null;
    orderDate?: Date | null;
    shipDate?: Date | null;
    customerId?: number | null;
    orderTotal?: number | null;
    id?: number | null;
    timeStamp?: string | null;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNavigation = data["CustomerNavigation"] ? Customer.fromJS(data["CustomerNavigation"]) : <any>null;
            if (data["OrderDetails"] && data["OrderDetails"].constructor === Array) {
                this.orderDetails = [] as any;
                for (let item of data["OrderDetails"])
                    this.orderDetails!.push(OrderDetail.fromJS(item));
            }
            this.orderDate = data["OrderDate"] ? new Date(data["OrderDate"].toString()) : <any>null;
            this.shipDate = data["ShipDate"] ? new Date(data["ShipDate"].toString()) : <any>null;
            this.customerId = data["CustomerId"] !== undefined ? data["CustomerId"] : <any>null;
            this.orderTotal = data["OrderTotal"] !== undefined ? data["OrderTotal"] : <any>null;
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerNavigation"] = this.customerNavigation ? this.customerNavigation.toJSON() : <any>null;
        if (this.orderDetails && this.orderDetails.constructor === Array) {
            data["OrderDetails"] = [];
            for (let item of this.orderDetails)
                data["OrderDetails"].push(item.toJSON());
        }
        data["OrderDate"] = this.orderDate ? formatDate(this.orderDate) : <any>null;
        data["ShipDate"] = this.shipDate ? formatDate(this.shipDate) : <any>null;
        data["CustomerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["OrderTotal"] = this.orderTotal !== undefined ? this.orderTotal : <any>null;
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface IOrder {
    customerNavigation?: Customer | null;
    orderDetails?: OrderDetail[] | null;
    orderDate?: Date | null;
    shipDate?: Date | null;
    customerId?: number | null;
    orderTotal?: number | null;
    id?: number | null;
    timeStamp?: string | null;
}

export class Customer implements ICustomer {
    fullName?: string | null;
    emailAddress!: string;
    password!: string;
    id?: number | null;
    timeStamp?: string | null;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["FullName"] !== undefined ? data["FullName"] : <any>null;
            this.emailAddress = data["EmailAddress"] !== undefined ? data["EmailAddress"] : <any>null;
            this.password = data["Password"] !== undefined ? data["Password"] : <any>null;
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["EmailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["Password"] = this.password !== undefined ? this.password : <any>null;
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface ICustomer {
    fullName?: string | null;
    emailAddress: string;
    password: string;
    id?: number | null;
    timeStamp?: string | null;
}

export class CartWithCustomerInfo implements ICartWithCustomerInfo {
    customer?: Customer | null;
    cartRecords?: CartRecordWithProductInfo[] | null;

    constructor(data?: ICartWithCustomerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["Customer"] ? Customer.fromJS(data["Customer"]) : <any>null;
            if (data["CartRecords"] && data["CartRecords"].constructor === Array) {
                this.cartRecords = [] as any;
                for (let item of data["CartRecords"])
                    this.cartRecords!.push(CartRecordWithProductInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CartWithCustomerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CartWithCustomerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>null;
        if (this.cartRecords && this.cartRecords.constructor === Array) {
            data["CartRecords"] = [];
            for (let item of this.cartRecords)
                data["CartRecords"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICartWithCustomerInfo {
    customer?: Customer | null;
    cartRecords?: CartRecordWithProductInfo[] | null;
}

export class CartRecordWithProductInfo implements ICartRecordWithProductInfo {
    id?: number | null;
    description?: string | null;
    modelNumber?: string | null;
    modelName?: string | null;
    productImage?: string | null;
    productImageLarge?: string | null;
    productImageThumb?: string | null;
    unitsInStock?: number | null;
    currentPrice?: number | null;
    categoryId?: number | null;
    categoryName?: string | null;
    dateCreated?: Date | null;
    customerId!: number;
    quantity!: number;
    lineItemTotal?: number | null;
    productId!: number;
    timeStamp?: string | null;

    constructor(data?: ICartRecordWithProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"] !== undefined ? data["Id"] : <any>null;
            this.description = data["Description"] !== undefined ? data["Description"] : <any>null;
            this.modelNumber = data["ModelNumber"] !== undefined ? data["ModelNumber"] : <any>null;
            this.modelName = data["ModelName"] !== undefined ? data["ModelName"] : <any>null;
            this.productImage = data["ProductImage"] !== undefined ? data["ProductImage"] : <any>null;
            this.productImageLarge = data["ProductImageLarge"] !== undefined ? data["ProductImageLarge"] : <any>null;
            this.productImageThumb = data["ProductImageThumb"] !== undefined ? data["ProductImageThumb"] : <any>null;
            this.unitsInStock = data["UnitsInStock"] !== undefined ? data["UnitsInStock"] : <any>null;
            this.currentPrice = data["CurrentPrice"] !== undefined ? data["CurrentPrice"] : <any>null;
            this.categoryId = data["CategoryId"] !== undefined ? data["CategoryId"] : <any>null;
            this.categoryName = data["CategoryName"] !== undefined ? data["CategoryName"] : <any>null;
            this.dateCreated = data["DateCreated"] ? new Date(data["DateCreated"].toString()) : <any>null;
            this.customerId = data["CustomerId"] !== undefined ? data["CustomerId"] : <any>null;
            this.quantity = data["Quantity"] !== undefined ? data["Quantity"] : <any>null;
            this.lineItemTotal = data["LineItemTotal"] !== undefined ? data["LineItemTotal"] : <any>null;
            this.productId = data["ProductId"] !== undefined ? data["ProductId"] : <any>null;
            this.timeStamp = data["TimeStamp"] !== undefined ? data["TimeStamp"] : <any>null;
        }
    }

    static fromJS(data: any): CartRecordWithProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CartRecordWithProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id !== undefined ? this.id : <any>null;
        data["Description"] = this.description !== undefined ? this.description : <any>null;
        data["ModelNumber"] = this.modelNumber !== undefined ? this.modelNumber : <any>null;
        data["ModelName"] = this.modelName !== undefined ? this.modelName : <any>null;
        data["ProductImage"] = this.productImage !== undefined ? this.productImage : <any>null;
        data["ProductImageLarge"] = this.productImageLarge !== undefined ? this.productImageLarge : <any>null;
        data["ProductImageThumb"] = this.productImageThumb !== undefined ? this.productImageThumb : <any>null;
        data["UnitsInStock"] = this.unitsInStock !== undefined ? this.unitsInStock : <any>null;
        data["CurrentPrice"] = this.currentPrice !== undefined ? this.currentPrice : <any>null;
        data["CategoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["CategoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["DateCreated"] = this.dateCreated ? formatDate(this.dateCreated) : <any>null;
        data["CustomerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["Quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["LineItemTotal"] = this.lineItemTotal !== undefined ? this.lineItemTotal : <any>null;
        data["ProductId"] = this.productId !== undefined ? this.productId : <any>null;
        data["TimeStamp"] = this.timeStamp !== undefined ? this.timeStamp : <any>null;
        return data; 
    }
}

export interface ICartRecordWithProductInfo {
    id?: number | null;
    description?: string | null;
    modelNumber?: string | null;
    modelName?: string | null;
    productImage?: string | null;
    productImageLarge?: string | null;
    productImageThumb?: string | null;
    unitsInStock?: number | null;
    currentPrice?: number | null;
    categoryId?: number | null;
    categoryName?: string | null;
    dateCreated?: Date | null;
    customerId: number;
    quantity: number;
    lineItemTotal?: number | null;
    productId: number;
    timeStamp?: string | null;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}